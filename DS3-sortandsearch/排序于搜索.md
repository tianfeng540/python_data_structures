一、搜索

item in [1,2,3,4]

顺序查找：当数据项存储在列表这类集合中时，我们说它们具有线性或顺序关系。每个数据项都存储在相对于其他数据项的位置

在Python列表中，这些相对位置是单个项的索引值。由于这些索引值是有序的，我们可以按照顺序访问它们。这个过程产生了第一种搜索技术---顺序查找

练习：写一个函数，该函数需要一个列表和我们正在搜索的项作为参数，并返回一个是否存在的布尔值。found = False

总之，只有在我们没有找到该项的情况下，才通过列表排序来改进顺序查找

二分查找：从中间项开始，

通常二分查找比顺序查找更好。

如果排序一次，要查找多次，这个时候可以排序

对于一些大型列表，一次排序花费时间较长，那么久从一开始就执行顺序查找

Hash查找 :可以在O(1)时间内搜索的数据结构，这个概念被称为Hash查找

哈希表是一种容易找到他们的方式存储的项的集合。

哈希表中的每个位置，通常称为一个槽，可以容纳一个项，并且从由0开始的整数值命名

最初，哈希表不包含项，因此每个槽都是空的。我们可以通过使用列表来实现一个哈希表，每个元素的初始值都为None

项和该项在散列表中所有的槽之间的映射被称为Hash函数，Hash函数将收集集合中的任何项，并在槽名范围内返回一个整数。

54，26，93，17，77，31 表的长度为11

余数法：item % 11 54%11 = 10 26%11 = 4 93%11 = 5 17%11 = 6 77%11 = 0 31%11 = 9

11个槽中的6个被占用，这被称为负载因子，通常表示 =项数/表大小

当我们搜索一个项时，只需要使用哈希函数来计算项的槽名称，然后检查哈希表以查看它是否存在。该搜索操作是O(1)，因为需要一定的时间来计算散列值，然后在该位置索引散列表。如果一切正常，就是一个恒定时间的搜索算法

但是，只有每个项映射到哈希表中的唯一位置，这个技术才起作用。44，33，55这些元素通过余数法，应该都处在一个槽中，这种现象称为碰撞（冲突）

持续的寻找优化的Hash函数，解决以上冲突

Hash函数

给定项的集合，将每个项映射到唯一槽的散列函数被称为完美散列函数。

没有完美散列函数，仍然也可以提高性能

怎么样才能把项放到唯一的槽中？ 增加列表的大小，使其可以容纳项范围中的每个可能值。

存放社保号码，9位 ，大约需要十亿个槽，20个人，浪费大量的内存

“创建一个散列函数，最大限度的减少冲突数，易于计算，均匀分布在哈希表中的项目”

​ 升级版Hash函数：

​ 分组求和法：将项划分为相等大小的块，然后这些块加在一起以求出散列值。比如：436-555-4601，取出数字，并将它们分成2位数（43，65，55，46，01），和210，假设哈希表有11个槽，210%11 = 1，因此电话号码436-555-4601散列到槽1。一些分组求和法会在求和之前每隔一个反转，（43，56，55，64，01）和219，219%11 = 10

​ 平方取中法：首先对该项进行平方，然后提取一部分数字结果。比如：项44，先计算平方44^2 = 1936，取出中间两个数字93，93%11 = 5

冲突解决

冲突解决：当两个项散列到同一个槽时，我们必须有一个系统方法将第二个项放到散列表中，这个过程叫做冲突解决。

解决冲突的一种方法就是查找散列表，找到另一个空槽保存导致冲突的项。从原始哈希值位置开始，然后以顺序方式移动槽，直到遇到第一个空槽。可能需要回到第一个槽以查找整个散列表。这种冲突解决过程叫做开放寻址，线性探索的开放寻址技术

[0 , 1 ,2 , 3 ,4, 5, 6, 7, 8, 9, 10] 44,55,20

​ [77 None None None 26 93 17 None None 31 53]

放44 [77 44 None None 26 93 17 None None 31 53]

放55 [77 44 55 None 26 93 17 None None 31 53]

放20 [77 44 55 20 26 93 17 None None 31 53]

使用开放寻址和线性探测建立了哈希表，就必须使用相同的方法来搜索项。假设我们寻找93和20的过程

二、排序

什么是排序？

首先，必须比较两个值以查看哪个更小（或更大）。为了对集合进行排序，需要一些系统的方法来比较值，以查看是否有问题。衡量排序过程的效率：比较的总数（尽可能减少比对的次数）。当值处于不正确的位置的时候，需要交换它们。交换操作比较浪费时间和内存，所以评价一个排序算法的效率的时候：比较的总数和交换的总数